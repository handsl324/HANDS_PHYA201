# -*- coding: utf-8 -*-
"""PHYA 201 HW4 code

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YXh_4STFVEIg-xV1O_ubDuBhKFljch9M
"""

import math
import numpy as np
import matplotlib.pyplot as plt

q = 4.8e-10 #statcoulombs; charge of proton
ap = 1 #accleration 
c = 3e10 #centimeters per second

def velocity(gamma):
  #this function returns v/c based on a given gamma 
  return np.sqrt(1-1/gamma**2)

def parallel(gamma, theta):
  #this function takes in a value of gamma and the angle and returns the parallel power 
  #calls the velocity function
  A = q**2 * ap**2 / (4*math.pi * c**3)
  pow = A * np.sin(theta)**2 / (gamma**2 *(1-velocity(gamma)*np.cos(theta))**2) #np.trig is in radians
  return pow

def perpend(gamma, theta):
  #this function takes in a value of gamma and the angle and returns the perpendicular power
  #calls the velocity and parallel function
  A = q**2 * ap**2 / (4*math.pi * c**3)
  return (A-parallel(gamma,theta))/(1-velocity(gamma)*np.cos(theta))**4

def para(gam):
  #this function takes a value of gamma, 
  #calculates the parallel power using the parallel function, 
  #calculates the x and z components of the power and plots the power distributions
  t = 0
  tmax = 2* math.pi
  dt = 0.0001
  N = math.ceil(tmax/dt)

  par = []
  th = []

  for i in range(N):
    par.append(parallel(gam,t))
    th.append(t)
    t+=dt

  x = []
  y = []
  for i in range(len(par)):
    x.append(np.cos(th[i])*par[i])
    y.append(np.sin(th[i])*par[i])
  plt.plot(x,y, color = 'r')
  plt.title("parallel power distribution")
  plt.axhline(0,color = 'gray', linestyle = 'dashed')
  plt.axvline(0,color = 'gray', linestyle = 'dashed')
  plt.xlabel('x')
  plt.ylabel('z')
  plt.show()

def perp(gam):
  #this function takes a value of gamma, 
  #calculates the perpendicular power using the perpend function, 
  #calculates the x and z components of the power and plots the power distributions
  t = 0 #starting angle
  tmax = 2* math.pi #maximum angle
  dt = 0.0001 #step size
  N = math.ceil(tmax//dt) #number of steps

  per = []
  th = []
  #calculating power for range of angles
  for i in range(N):
    per.append(perpend(gam,t))
    th.append(t)
    t+=dt

  #plot!!
  x = []
  z = []
  for i in range(len(per)):
    x.append(np.cos(th[i])*per[i]) #x component
    z.append(np.sin(th[i])*per[i]) #z component
  plt.plot(x,z, color = 'b')
  plt.title("perpendicular power distribution")
  plt.axhline(0,color = 'gray', linestyle = 'dashed')
  plt.axvline(0,color = 'gray', linestyle = 'dashed')
  plt.xlabel('x')
  plt.ylabel('z')
  plt.show()

  plt.plot(x,z, color = 'b')
  plt.title("perpendicular power distribution zoomed in")
  plt.axhline(0,color = 'gray', linestyle = 'dashed')
  plt.axvline(0,color = 'gray', linestyle = 'dashed')
  plt.xlabel('x')
  plt.ylabel('z')
  plt.xlim(0, max(x)/500)#(-0.3e-41,0.3e-41)
  plt.ylim(-max(z)/50,max(z)/50)#(0,0.8e-41)
  plt.show()

"""The equations for $\frac{dP}{dΩ}$ give us the power along a given angle $\theta$. By taking the cos and sin of $\theta$ and then multiplying it by $\frac{dP}{dΩ}$, we are finding the x and z components of the power per solid angle respectively. Plotting these components gives us the power distribution spatially.

# $\gamma$ = 5
"""

g = 5

para(g)

perp(g)

"""# $\gamma$ = 10
Note how the scale has decreased for parallel power and increased in perpendicular power. This change implies that for velocity closer to the speed of light (higher gamma), there is more beaming of the power in the perpendicular direction.
"""

g = 10

para(g)

perp(g)

"""# $\gamma = 100$

again the scales change like before.
"""

g = 100

para(g)

perp(g)

"""# Code for Question 2 Part C"""

a = 0
amax = math.pi/2
da = 0.01
astep = math.ceil(amax/da)
vel = 0.9*c
vtan = []
ang = []

for i in range(astep):
  vtan.append(vel*np.sin(a)/(1-(vel/c)*np.cos(a)))
  ang.append(a)
  a+=da

t1 = 0
t2 = 20
t3 = 40
t4 = 60
t5 = 80
t6 = 100

nvtan = [each *-1 for each in vtan]
vtan1 = [each *t1 for each in vtan]
vtan2 = [each *t2 for each in vtan]
vtan3 = [each *t3 for each in vtan]
vtan4 = [each *t4 for each in vtan]
vtan5 = [each *t5 for each in vtan]
vtan6 = [each *t6 for each in vtan]

plt.plot(ang,vtan1, label = 't = 0 sec')
plt.plot(ang,vtan2, label = 't = 20')
plt.plot(ang,vtan3, label = 't = 40')
plt.plot(ang,vtan4, label = 't = 60')
plt.plot(ang,vtan5, label = 't = 80')
plt.plot(ang,vtan6, label = 't = 100')

plt.axvline(np.arccos(vel/c), color = 'r', linestyle = 'dashed')

plt.xlabel('angle')
plt.ylabel('transverse distance')
plt.legend()
plt.grid()
plt.show()

